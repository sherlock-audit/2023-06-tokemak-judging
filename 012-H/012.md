Magnificent Gingham Bear

high

# Liquidations sometimes will not work due to incorrect logic inside queueNewRewards
## Summary
queueNewRewards is trying to transfer too much LiquidationRow on liquidation
## Vulnerability Detail
Whenever system conducts the liquidation process at some point there will be a call to queueNewRewards, lets note that approve is to  `amount`
```solidity
            // approve main rewarder to pull the tokens
            LibAdapter._approve(IERC20(params.buyTokenAddress), address(mainRewarder), amount);
            mainRewarder.queueNewRewards(amount);
```
[LiquidationRow.sol#L276](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L276)
Let's look at `queueNewRewards` at some point startingQueuedRewards will not be 0 thus 
`newRewards = newRewards + startingQueuedRewards`
and rewarded will try to request those funds from liquidationRow, but we remember that allowance is only `newRewards` and not `newRewards + startingQueuedRewards`, so this will fail
`IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards)`

```solidity
    function queueNewRewards(uint256 newRewards) external onlyWhitelisted {
        uint256 startingQueuedRewards = queuedRewards;
        uint256 startingNewRewards = newRewards;

        newRewards += startingQueuedRewards;

        if (block.number >= periodInBlockFinish) {
            notifyRewardAmount(newRewards);
            queuedRewards = 0;
        } else {
            uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);
            uint256 currentAtNow = rewardRate * elapsedBlock;
            uint256 queuedRatio = currentAtNow * 1000 / newRewards;

            if (queuedRatio < newRewardRatio) {
                notifyRewardAmount(newRewards);
                queuedRewards = 0;
            } else {
                queuedRewards = newRewards;
            }
        }

        emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);

        // Transfer the new rewards from the caller to this contract.
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards); // @audit should be newRewards - startingQueuedRewards
    }

```
[src/rewarders/AbstractRewarder.sol#L239](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L239)
## Impact

## Code Snippet

## Tool used

Manual Review

## Recommendation
There suppose to be a subtraction because we already transferred `startingQueuedRewards` in previous calls
```diff
    function queueNewRewards(uint256 newRewards) external onlyWhitelisted {
        uint256 startingQueuedRewards = queuedRewards;
        uint256 startingNewRewards = newRewards;

        newRewards += startingQueuedRewards;

        if (block.number >= periodInBlockFinish) {
            notifyRewardAmount(newRewards);
            queuedRewards = 0;
        } else {
            uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);
            uint256 currentAtNow = rewardRate * elapsedBlock;
            uint256 queuedRatio = currentAtNow * 1000 / newRewards;

            if (queuedRatio < newRewardRatio) {
                notifyRewardAmount(newRewards);
                queuedRewards = 0;
            } else {
                queuedRewards = newRewards;
            }
        }

        emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);

        // Transfer the new rewards from the caller to this contract.
-        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards);
+        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards - startingQueuedRewards);
    }

```